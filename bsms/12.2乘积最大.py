# 今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。
#
# 在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。
#
# 活动中，主持人给所有参加活动的选手出了这样一道题目：
#
# 设有一个长度为 N 的数字串，要求选手使用 K 个乘号将它分成 K+1 个部分，找出一种分法，使得这 K+1 个部分的乘积最大。
#
# 同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：
#
# 有一个数字串：312， 当 N=3，K=1 时会有以下两种分法：
#
# 1）3*12=36
#
# 2）31*2=62
#
# 这时，符合题目要求的结果是：31*2=62。
#
# 现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。
#
# 输入格式
# 第一行共有2个自然数 N，K。
#
# 第二行是一个长度为 N 的数字串。
#
# 输出格式
# 输出所求得的最大乘积（一个自然数）。
#
# 数据范围
# 2≤N≤10,
# 1≤K≤6,
# 数据保证 K<N
# 输入样例：
# 4 2
# 1231
# 输出样例：
# 62


def dfs(u, s, v, p):  # u当前枚举到几个数字 s当前有几个数了 v当前的数是多少 p当前乘积
    if u == n:
        if s == k + 1:
            return p
        return -1
    else:
        v = v * 10 + nums[u]
        t1 = dfs(u + 1, s, v, p)  # 在第u位后不加乘号
        t2 = dfs(u + 1, s + 1, 0, p * v)  # 在第u位后加乘号
        return max(t1, t2)


n, k = list(map(int, input().split()))
nums = list(map(int, list(input())))
print(dfs(0, 0, 0, 1))
